/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  PromptLlmConfig,
  PromptLlmConfig$inboundSchema,
  PromptLlmConfig$Outbound,
  PromptLlmConfig$outboundSchema,
} from "./promptllmconfig.js";

/**
 * Request model to create a prompt.
 */
export type PromptCreateRequest = {
  /**
   * The prompt name
   */
  name: string;
  /**
   * The description of the prompt
   */
  description?: string | null | undefined;
  /**
   * The type of the prompt
   */
  type: string;
  /**
   * The prompt text that will be sent to the LLM at the beginning of the conversation
   */
  context?: string | null | undefined;
  /**
   * Names of tools to which the prompt has access
   */
  tools?: Array<string> | undefined;
  /**
   * LLM configuration for a prompt.
   */
  llmConfig: PromptLlmConfig;
  /**
   * Whether session end functionality is enabled for this prompt
   */
  sessionEndEnabled?: boolean | undefined;
  /**
   * ID of the optional session end tool associated with the prompt
   */
  sessionEndToolId?: number | null | undefined;
  /**
   * The comments for the most recent edit to the prompt
   */
  editComments?: string | null | undefined;
  /**
   * Whether to include the default tools (`hangup`) in the list of tools for the prompt. If you disable this during creation, you might want to disable it during updates as well, otherwise the default tools will be added when updating the prompt.
   */
  includeDefaultTools?: boolean | undefined;
};

/** @internal */
export const PromptCreateRequest$inboundSchema: z.ZodType<
  PromptCreateRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.nullable(z.string()).optional(),
  type: z.string(),
  context: z.nullable(z.string()).optional(),
  tools: z.array(z.string()).optional(),
  llm_config: PromptLlmConfig$inboundSchema,
  session_end_enabled: z.boolean().default(false),
  session_end_tool_id: z.nullable(z.number().int()).optional(),
  edit_comments: z.nullable(z.string()).optional(),
  include_default_tools: z.boolean().default(true),
}).transform((v) => {
  return remap$(v, {
    "llm_config": "llmConfig",
    "session_end_enabled": "sessionEndEnabled",
    "session_end_tool_id": "sessionEndToolId",
    "edit_comments": "editComments",
    "include_default_tools": "includeDefaultTools",
  });
});
/** @internal */
export type PromptCreateRequest$Outbound = {
  name: string;
  description?: string | null | undefined;
  type: string;
  context?: string | null | undefined;
  tools?: Array<string> | undefined;
  llm_config: PromptLlmConfig$Outbound;
  session_end_enabled: boolean;
  session_end_tool_id?: number | null | undefined;
  edit_comments?: string | null | undefined;
  include_default_tools: boolean;
};

/** @internal */
export const PromptCreateRequest$outboundSchema: z.ZodType<
  PromptCreateRequest$Outbound,
  z.ZodTypeDef,
  PromptCreateRequest
> = z.object({
  name: z.string(),
  description: z.nullable(z.string()).optional(),
  type: z.string(),
  context: z.nullable(z.string()).optional(),
  tools: z.array(z.string()).optional(),
  llmConfig: PromptLlmConfig$outboundSchema,
  sessionEndEnabled: z.boolean().default(false),
  sessionEndToolId: z.nullable(z.number().int()).optional(),
  editComments: z.nullable(z.string()).optional(),
  includeDefaultTools: z.boolean().default(true),
}).transform((v) => {
  return remap$(v, {
    llmConfig: "llm_config",
    sessionEndEnabled: "session_end_enabled",
    sessionEndToolId: "session_end_tool_id",
    editComments: "edit_comments",
    includeDefaultTools: "include_default_tools",
  });
});

export function promptCreateRequestToJSON(
  promptCreateRequest: PromptCreateRequest,
): string {
  return JSON.stringify(
    PromptCreateRequest$outboundSchema.parse(promptCreateRequest),
  );
}
export function promptCreateRequestFromJSON(
  jsonString: string,
): SafeParseResult<PromptCreateRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PromptCreateRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PromptCreateRequest' from JSON`,
  );
}
