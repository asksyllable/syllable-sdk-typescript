/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  ConditionalText,
  ConditionalText$inboundSchema,
  ConditionalText$Outbound,
  ConditionalText$outboundSchema,
} from "./conditionaltext.js";
import {
  InputParameter,
  InputParameter$inboundSchema,
  InputParameter$Outbound,
  InputParameter$outboundSchema,
} from "./inputparameter.js";
import {
  NextStep,
  NextStep$inboundSchema,
  NextStep$Outbound,
  NextStep$outboundSchema,
} from "./nextstep.js";
import {
  StepEventActions,
  StepEventActions$inboundSchema,
  StepEventActions$Outbound,
  StepEventActions$outboundSchema,
} from "./stepeventactions.js";
import {
  StepTools,
  StepTools$inboundSchema,
  StepTools$Outbound,
  StepTools$outboundSchema,
} from "./steptools.js";

export type Instructions = ConditionalText | string;

export type Next = NextStep | string;

export type Step = {
  /**
   * The unique identifier of the step.
   */
  id: string;
  /**
   * The goal of the step.
   */
  goal: string;
  /**
   * The instructions for the step.
   */
  instructions?: Array<ConditionalText | string> | undefined;
  /**
   * Configuration for tools available in a step.
   */
  tools?: StepTools | undefined;
  /**
   * The inputs for the step.
   */
  inputs?: Array<InputParameter> | undefined;
  /**
   * Actions to perform when events occur (enter, presubmit, submit).
   */
  on?: StepEventActions | undefined;
  /**
   * The next steps to execute.
   */
  next?: Array<NextStep | string> | undefined;
};

/** @internal */
export const Instructions$inboundSchema: z.ZodType<
  Instructions,
  z.ZodTypeDef,
  unknown
> = z.union([ConditionalText$inboundSchema, z.string()]);
/** @internal */
export type Instructions$Outbound = ConditionalText$Outbound | string;

/** @internal */
export const Instructions$outboundSchema: z.ZodType<
  Instructions$Outbound,
  z.ZodTypeDef,
  Instructions
> = z.union([ConditionalText$outboundSchema, z.string()]);

export function instructionsToJSON(instructions: Instructions): string {
  return JSON.stringify(Instructions$outboundSchema.parse(instructions));
}
export function instructionsFromJSON(
  jsonString: string,
): SafeParseResult<Instructions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Instructions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Instructions' from JSON`,
  );
}

/** @internal */
export const Next$inboundSchema: z.ZodType<Next, z.ZodTypeDef, unknown> = z
  .union([NextStep$inboundSchema, z.string()]);
/** @internal */
export type Next$Outbound = NextStep$Outbound | string;

/** @internal */
export const Next$outboundSchema: z.ZodType<Next$Outbound, z.ZodTypeDef, Next> =
  z.union([NextStep$outboundSchema, z.string()]);

export function nextToJSON(next: Next): string {
  return JSON.stringify(Next$outboundSchema.parse(next));
}
export function nextFromJSON(
  jsonString: string,
): SafeParseResult<Next, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Next$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Next' from JSON`,
  );
}

/** @internal */
export const Step$inboundSchema: z.ZodType<Step, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    goal: z.string(),
    instructions: z.array(z.union([ConditionalText$inboundSchema, z.string()]))
      .optional(),
    tools: StepTools$inboundSchema.optional(),
    inputs: z.array(InputParameter$inboundSchema).optional(),
    on: StepEventActions$inboundSchema.optional(),
    next: z.array(z.union([NextStep$inboundSchema, z.string()])).optional(),
  });
/** @internal */
export type Step$Outbound = {
  id: string;
  goal: string;
  instructions?: Array<ConditionalText$Outbound | string> | undefined;
  tools?: StepTools$Outbound | undefined;
  inputs?: Array<InputParameter$Outbound> | undefined;
  on?: StepEventActions$Outbound | undefined;
  next?: Array<NextStep$Outbound | string> | undefined;
};

/** @internal */
export const Step$outboundSchema: z.ZodType<Step$Outbound, z.ZodTypeDef, Step> =
  z.object({
    id: z.string(),
    goal: z.string(),
    instructions: z.array(z.union([ConditionalText$outboundSchema, z.string()]))
      .optional(),
    tools: StepTools$outboundSchema.optional(),
    inputs: z.array(InputParameter$outboundSchema).optional(),
    on: StepEventActions$outboundSchema.optional(),
    next: z.array(z.union([NextStep$outboundSchema, z.string()])).optional(),
  });

export function stepToJSON(step: Step): string {
  return JSON.stringify(Step$outboundSchema.parse(step));
}
export function stepFromJSON(
  jsonString: string,
): SafeParseResult<Step, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Step$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Step' from JSON`,
  );
}
